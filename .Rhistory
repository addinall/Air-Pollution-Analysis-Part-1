complete("specdata")
cr <- corr("specdata", 400)
complete("specdata", 30:25)
c <- complete("specdata")
View(c)
View(c)
View(c)
str(c)
length(corr("specdata",400))
complete("specdata", 30:25)
source("corr.R")
length(corr("specdata",400))
c <- corr("specdata",400)
nrow(c)
length(c)
source("corr.R")
c <- corr("specdata",400)
c <- corr("specdata",150)
v <- c(0)
v
class(v)
length(v)
v <- c(v, 999)
v
length(v)
vl <- vector(length=127)
vl
vl[1] -> 999
vl[1] <- 999
v
vl
head(vl)
summary(vl)
?read.csv
?vector
source("corr.R")
source("corr.R")
cr  <- corr("specdata",400)
head cr
head(cr)
head(cr)
?round
source(corr.R)
list.files()
source("corr.R")
cr <- corr("specdata", 150)
head(cr)
summary(cr)
cr <- corr("specdata", 400)
head(cr)
summary(cr)
cr <- corr("specdata", 5000)
summary(cr)
length(cr)
cr <- corr("specdata")
summary(cr)
length(cr)
source("corr.R")
cr <- corr("specdata", 400)
head(cr)
summary(cr)
submit()
submit()
submit()
?<<-
g <- list(changed=1, m=matrix(c(1:4), nrow = 2, ncol = 2), i = FALSE)
g
g$m
gg <- list(f=function(x){x <- x + 1}, id = 4)
gg
SHARED_MATRIX_OBJECT <- list (
change_counter  = 1,
changed         = function(){ change_counter <- change_counter + 1 },
locked          = FALSE,
lock            = function() { locked = TRUE },
unlock          = function() { locked = FALSE },
is.locked       = function() { return(locked) })
SHARED_MATRIX_OBJECT
SHARED_MATRIX_OBJECT$lock()
SHARED_MATRIX_OBJECT
SHARED_MATRIX_OBJECT$unlock()
SHARED_MATRIX_OBJECT
SHARED_MATRIX_OBJECT$is.locked
SHARED_MATRIX_OBJECT$is.locked()
SHARED_MATRIX_OBJECT$lock()
SHARED_MATRIX_OBJECT
SHARED_MATRIX_OBJECT$lock
SHARED_MATRIX_OBJECT$lock()
SHARED_MATRIX_OBJECT
SHARED_MATRIX_OBJECT <- list (
change_counter  = 1,
changed         = function(){ change_counter <- change_counter + 1 },
locked          = FALSE,
lock            = function() { SHARED_MATRIX_OBJECT$locked = TRUE },
unlock          = function() { SHARED_MATRIX_OBJECT$locked = FALSE },
is.locked       = function() { return(SHARED_MATRIX_OBJECT$locked) })
g <- SHARED_MATRIX_OBJECT
idententical(g, SHARED_MATRIX_OBJECT)
g
g$lock()
g
SHARED_MATRIX_OBJECT
g
g$locked = TRUE
g
g$locked = FALSE
g
S <- list (
change_counter  = 1,
changed         = function(){ change_counter <- change_counter + 1 },
locked          = FALSE,
lock            = function() { S$locked = TRUE },
unlock          = function() { S$locked = FALSE },
is.locked       = function() { return(S$locked) })
S
S$lock()
s
S
GLOBAL <- list( counter = 1,
locked = FALSE,
important_value = 42,
copy_of_important_value = 42,
lock = function() { GLOBAL$locked = TRUE },
unlock = function() { GLOBAL$locked = FALSE },
is_locked = function() { return($GLOBAL$locked },
visit = function() { GLOBAL$counter <- GLOBAL$counter + 1 })
GLOBAL <- list( counter = 1,
locked = FALSE,
important_value = 42,
copy_of_important_value = 42,
lock = function() { GLOBAL$locked = TRUE },
unlock = function() { GLOBAL$locked = FALSE },
is_locked = function() { return($GLOBAL$locked )},
visit = function() { GLOBAL$counter <- GLOBAL$counter + 1 })
GLOBAL <- list( counter = 1,
locked = FALSE,
important_value = 42,
copy_of_important_value = 42,
lock = function() { GLOBAL$locked = TRUE },
unlock = function() { GLOBAL$locked = FALSE },
is_locked = function() { return(GLOBAL$locked )},
visit = function() { GLOBAL$counter <- GLOBAL$counter + 1 })
GLOBAL$locked
GLOBAL$locked -> TRUE
GLOBAL$locked <- TRUE
GLOBAL$locked
GLOBAL$unlock()
GLOBAL$locked
install.packages("proto", dependencies = TRUE)
library("proto")
GLOBAL <- proto( counter = 1,
locked = FALSE,
important_value = 42,
copy_of_important_value = 42,
lock = function(.) { .$locked = TRUE },
unlock = function(.) { .$locked = FALSE },
is_locked = function(.) { return(.$locked )},
visit = function(.) { .$counter <- .$counter + 1 })
GLOBAL$locked <- TRUE
GLOBAL$unlock()
GLOBAL$locked
getGlobal <- function() {
counter <- 1
locked <- FALSE
important_value <- 42
list(
is_locked = function() locked,
lock = function() locked<<-TRUE,
unlock = function() locked<<-FALSE,
visit = function() {counter <<- counter + 1 }
)
}
GLOBAL <- getGlobal()
GLOBAL$is_locked()
GLOBAL$lock()
GLOBAL$is_locked()
## ----------------------
getGlobal <- function() {
counter <- 1
locked <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
list(
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x ) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
GLOBAL <- getGlobal()
## ----------------------
getGlobal <- function() {
counter <- 1
locked <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
list(
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
GLOBAL <- getGlobal()
}
GLOBAL
GLOBAL$is_locked()
## ----------------------
getGlobal <- function() {
counter <- 1
locked <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
list(
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
GLOBAL <- getGlobal()
function do(x) {
function it(x) {
function it(x) { GLOBAL$visit() }
function it() GLOBAL$visit
it <- function { GLOBAL$visit() }
it <- function() { GLOBAL$visit() }
it()
it()
it()
it()
GLOBAL
GLOBAL
GLOBAL$locked()
GLOBAL$locked
GLOBAL
GLOBAL$is_locked
GLOBAL$is_locked()
GLOBAL$lock()
GLOBAL$is_locked()
GLOBAL$unlock()
GLOBAL$is_locked()
set.seed(1)
rpois(5,2)
set.seed(1)
rpois(5,2)
set.seed(1)
rpois(5,2)
rpois(5,2)
set.seed(1)
rpois(5,2)
__constructor <- function( x, ...) { x }
constructor <- function( x, ...) { x }
get_global <- function() {
counter <- 1
locked <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
list(
constructor     = function() { print("That's IT") },
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
visits,         = function() { counter },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
global <- get_global()
get_global <- function() {
counter <- 1
locked <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
list(
constructor     = function() { print("That's IT") },
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
visits          = function() { counter },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
global <- get_global()
global
f <- function() { global }
f
f()
ls global
ls(global)
l <-function(x) { global$is_locked() }
l()
l1 <- function(x) { global$lock() }
l1()
l()
l2 <- function(x) { global$unlock() }
l2()
l()
str(global)
summary(global)
global
sample(1:44,6)
set.seed(10)
x <- rbinom(10, 10, 0.5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
plot(x,y)
plot(x,y)
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
y <- 4
x1 <- 2
x2 <-40
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
system.time(readLines("http://www.addinall.com.au")
)
get_global <- function() {
## Private properties
## can ONLY be accessed by accessors and mutators in here
secret  <- "a2e57d6b9b8712f52a149e96bc31d32c"
counter <- 1
locked  <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
## Private methods
spin_lock   = function() { while (spinning){} }
check_id    = finction() { secret }
## Public methods
list(
constructor     = function() { print("That's IT") },
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
visits          = function() { counter },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
global <- get_global()
get_global <- function() {
## Private properties
## can ONLY be accessed by accessors and mutators in here
secret  <- "a2e57d6b9b8712f52a149e96bc31d32c"
counter <- 1
locked  <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
## Private methods
spin_lock   = function() { while (spinning) }
check_id    = function() { secret }
## Public methods
list(
constructor     = function() { print("That's IT") },
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
visits          = function() { counter },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
global <- get_global()
get_global <- function() {
## Private properties
## can ONLY be accessed by accessors and mutators in here
secret  <- "a2e57d6b9b8712f52a149e96bc31d32c"
counter <- 1
locked  <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
## Private methods
spin_lock   <- function() { while (spinning) }
check_id    <- function() { secret }
## Public methods
list(
constructor     = function() { print("That's IT") },
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
visits          = function() { counter },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
global <- get_global()
get_global <- function() {
## Private properties
## can ONLY be accessed by accessors and mutators in here
secret  <- "a2e57d6b9b8712f52a149e96bc31d32c"
counter <- 1
locked  <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
## Private methods
spin_lock   <- function() { }
check_id    <- function() { secret }
## Public methods
list(
constructor     = function() { print("That's IT") },
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
visits          = function() { counter },
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
global <- get_global()
global
##----------------------------------
spin_lock_contention <- function() {
## wait until the object lock clears before allowing
## MUTATORS
## access to SHARED memory
}
## -----------------------------
security_manager <- function() {
## control access to SHARED memory by way of
## interprocess shared secrets.  Access to the
## shared secret at this level is not possible,
## hence no arguments
}
## -------------------------
get_global <- function() {
## Private properties
## can ONLY be accessed by accessors and mutators in here
secret  <- "a2e57d6b9b8712f52a149e96bc31d32c"
counter <- 1
locked  <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
## Private methods
spin_lock   <- spin_lock_contention()
check_id    <- security_manager()
## Public methods
list(
constructor     = function() { print("That's IT") },
is_locked       = function() { locked },
lock            = function() { locked<<-TRUE },
unlock          = function() { locked<<-FALSE },
visit           = function() { counter <<- counter + 1 },
visits          = function() { counter },
build_matrix    = function(x){ global_matrix <- x build() }
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
global <- get_global()
## -------------------------
get_global <- function() {
## Private properties
## can ONLY be accessed by accessors and mutators in here
secret  <- "a2e57d6b9b8712f52a149e96bc31d32c"
counter <- 1
locked  <- FALSE
global_matrix <- matrix(c(1:16),nrow=4,ncol=4)
global_inverse_matrix <- matrix(c(16:1),nrow=1,ncol=1)
## Private methods
spin_lock   <- spin_lock_contention()
check_id    <- security_manager()
## Public methods
list(
constructor     = function() { print("That's IT") },
is_locked       = function() { locked },
lock            = function() { locked <<- TRUE },
unlock          = function() { locked <<- FALSE },
visit           = function() { counter <<- counter + 1 },
visits          = function() { counter },
build_matrix    = function(x){ global_matrix <- x }
gsolve          = function() { global_inverse_matrix <<- solve(global_matrix) },
gsolve_return   = function(x){ return( solve( x )) },
cache_return    = function() { return( global_matrix ) },
inverse_return  = function() { return( global_inverse_matrix ) }
)
}
global <- get_global()
